@compiler >= 6

include "List.aes"
include "Option.aes"
include "String.aes"
include "core/utils.aes"
include "core/interfaces.aes"

contract MintableMutableNFT =

    datatype event 
        = Transfer(address, address, int)
        | Approval(address, address, int, string)
        | ApprovalForAll(address, address, string)

    datatype metadata_type = URL | IPFS | OBJECT_ID | MAP
    datatype metadata = MetadataIdentifier(string) | MetadataMap(map(string, string))

    record meta_info =
        { name: string
        , symbol: string
        , base_url: option(string)
        , metadata_type : metadata_type }
    
    record state =
        { owner: address
        , meta_info: meta_info
        , owners: map(int, address)
        , balances: map(address, int)
        , approvals: map(int, address)
        , operators: map(address, map(address, bool))
        , metadata: map(int, metadata)
        , counter: int }

    stateful entrypoint init(name: string, symbol: string) = 
        require(String.length(name) >= 1, "STRING_TOO_SHORT_NAME")
        require(String.length(symbol) >= 1, "STRING_TOO_SHORT_SYMBOL")
        { owner = Contract.creator,
          meta_info = { name = name, symbol = symbol, base_url = None, metadata_type = MAP },
          owners = {},
          balances = {},
          approvals = {},
          operators = {},
          metadata = {},
          counter = 1 }
    
    stateful entrypoint mint(owner: address, metadata: option(metadata), data: option(string)) : int =
        require_contract_owner()
        switch(metadata)
            None =>
                abort("NO_METADATA_PROVIDED")
            Some(v) =>
                // TODO ensure that only MetadataMap can be used as metadata
                let token_id = state.counter
                put( state { counter = state.counter + 1, balances[owner = 0] @ b = b + 1, owners[token_id] = owner, metadata[token_id] = v } )
                switch(invoke_nft_receiver(Contract.address, owner, token_id, data))
                    (true, false) => abort("SAFE_TRANSFER_FAILED")
                    _ => Chain.event(Transfer(Contract.address, owner, token_id))
                token_id

    entrypoint aex141_extensions() : list(string) =
        ["mintable"]

    entrypoint meta_info() : meta_info = 
        state.meta_info

    entrypoint metadata(token_id: int) : option(metadata) = 
        Map.lookup(token_id, state.metadata)

    entrypoint balance(owner: address) : option(int) =
        Map.lookup(owner, state.balances)

    entrypoint owner(token_id: int) : option(address) =
        Map.lookup(token_id, state.owners)

    stateful entrypoint transfer(from: address, to: address, token_id: int, data: option(string)) : unit =
        require_authorized(token_id)
        require_token_owner(token_id, from)
        remove_approval(token_id)
        put( state { balances[from] @b = b - 1, balances[to = 0] @nb = nb + 1, owners[token_id] = to } )
        switch(invoke_nft_receiver(from, to, token_id, data))
            (true, false) => abort("SAFE_TRANSFER_FAILED")
            _ => Chain.event(Transfer(from, to, token_id))

    stateful entrypoint approve(approved: address, token_id: int, enabled: bool) : unit =
        require_authorized(token_id)
        if(enabled)
            put( state { approvals[token_id] = approved })
        else
            remove_approval(token_id)
        Chain.event(Approval(Call.caller, approved, token_id, Utils.bool_to_string(enabled)))

    stateful entrypoint approve_all(operator: address, enabled: bool) : unit =
        put( state { operators = { [Call.caller] = { [operator] = enabled }} } )
        Chain.event(ApprovalForAll(Call.caller, operator, Utils.bool_to_string(enabled)))

    entrypoint get_approved(token_id: int) : option(address) =
        Map.lookup(token_id, state.approvals)

    entrypoint is_approved(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.approvals))
            None => false
            Some(o) => o == a

    entrypoint is_approved_for_all(owner: address, operator: address) : bool =
        switch(Map.lookup(owner, state.operators))
            None => false
            Some(ops) =>
                switch(Map.lookup(operator, ops))
                    None => false
                    Some(v) => v

    function is_token_owner(token_id: int, a: address) : bool =
        switch(Map.lookup(token_id, state.owners))
            None => false
            Some(o) => o == a

    function require_contract_owner() : unit =
        require(Call.caller == state.owner, "ONLY_CONTRACT_OWNER_CALL_ALLOWED")

    function require_authorized(token_id: int) : unit =
        let owner = switch(owner(token_id))
            None => abort("INVALID_TOKEN_ID")
            Some(v) => v
        require(Call.caller == owner || is_approved(token_id, Call.caller) || is_approved_for_all(owner, Call.caller), "ONLY_OWNER_APPROVED_OR_OPERATOR_CALL_ALLOWED")

    function require_token_owner(token_id: int, a: address) : unit =
        require(is_token_owner(token_id, a), "ONLY_OWNER_CALL_ALLOWED")

    stateful function remove_approval(token_id: int) : unit =
        if(Map.member(token_id, state.approvals))
            put( state { approvals = Map.delete(token_id, state.approvals)})

    function invoke_nft_receiver(from: address, to: address, token_id: int, data: option(string)) : (bool * bool) =
        if(Address.is_contract(to))
            let c = Address.to_contract(to)
            switch(c.on_nft_received(from, to, token_id, data, protected = true) : option(bool))
                None => (true, false)
                Some(val) => (true, val)
        else
            (false, false)